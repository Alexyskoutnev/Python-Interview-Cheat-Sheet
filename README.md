# Python Interview Cheat Sheet

This cheat sheet provides an overview of common methods and techniques that are essential for Python-based coding interviews. Understanding these concepts and methods will help you solve a wide range of problems and improve your problem-solving skills.

## Basic Data Structures

### Lists

- `append()`: Add an element to the end of the list.
- `pop()`: Remove and return the last element of the list.
- `insert()`: Insert an element at a specified position.
- `index()`: Find the index of a specific value in the list.
- `remove()`: Remove the first occurrence of a specified value.
- `len()`: Get the length of the list.

### Sets

- `add()`: Add an element to the set.
- `remove()`: Remove an element from the set.
- `union()`: Perform the union of two sets.
- `intersection()`: Perform the intersection of two sets.
- `difference()`: Find the difference between two sets.

### Dictionaries

- `get()`: Retrieve the value associated with a key.
- `keys()`: Get a list of keys in the dictionary.
- `values()`: Get a list of values in the dictionary.
- `items()`: Get a list of key-value pairs in the dictionary.
- `len()`: Get the number of key-value pairs in the dictionary.

## Strings

- String manipulation: Slicing, concatenation, and searching.
- `str.split()`: Split a string into a list of substrings.
- `str.join()`: Join a list of strings into one string.
- `str.strip()`: Remove leading and trailing whitespace.
- `str.replace()`: Replace occurrences of a substring with another string.

## Arrays

- Utilize Numpy and its functions for numerical operations.

## Sorting and Searching

- Sorting: `sorted()`, `list.sort()`, `sorted(iterable, key=lambda x: ...)`.
- Binary search: `bisect.bisect()`, `bisect.bisect_left()`, `bisect.bisect_right()`.

## Hashing

- Use dictionaries for O(1) key-value lookup.

## Recursion

- Understand recursion and implement recursive functions.

## Dynamic Programming

- Apply techniques like memoization (caching) to optimize recursive algorithms.

## Graphs

- Understand graph representation (adjacency lists, adjacency matrices).
- Perform Depth-First Search (DFS) and Breadth-First Search (BFS).
- Implement shortest path algorithms (Dijkstra's, Bellman-Ford).
- Work with Minimum Spanning Trees (Prim's, Kruskal's).

## Trees

- Handle binary trees and Binary Search Trees (BST).
- Traverse trees (in-order, pre-order, post-order).
- Use Depth-First Search (DFS) on trees.
- Implement balancing algorithms for AVL trees and Red-Black trees.

## Heap

- Work with heaps and heap operations (heapify, heappush, heappop).

## Greedy Algorithms

- Understand and implement greedy strategies.

## Bit Manipulation

- Perform bitwise operations like AND, OR, XOR, and bit shifting.
- Check for and set/clear specific bits.

## Math

- Use basic mathematical operations.
- Generate and check prime numbers.
- Apply modular arithmetic.

## Geometry

- Apply computational geometry algorithms if required.

## Divide and Conquer

- Break down problems into smaller subproblems and combine their solutions.

## Two Pointers

- Utilize the two-pointer technique to solve problems by moving pointers inwards.

## Sliding Window

- Efficiently process subarrays or substrings using the sliding window technique.

## Regular Expressions

- Use Python's `re` module for pattern matching.

## Exception Handling

- Use `try`, `except`, and `finally` for error handling.

## Custom Data Structures

- Implement custom data structures such as queues, stacks, and linked lists.

## Functional Programming

- Use lambda functions, `map`, `filter`, and `reduce` for functional programming.

## Time and Space Complexity Analysis

- Understand Big O notation and analyze the efficiency of your code.